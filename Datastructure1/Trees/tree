class Node:

    def __init__(self, data):

        self.left = None
        self.right = None
        self.data = data

    def insert(self, data):
# Compare the new value with the parent node
        if self.data: #case 1: if data defined
            if data < self.data: #case 1: #if data < root defined
                if self.left is None: #left parse , if no node add data, else iterate till the end
                    self.left = Node(data)
                else:
                    self.left.insert(data)
            elif data > self.data: #if data > root, parse right
                if self.right is None: #if right has no node, add data else iterate till the end
                    self.right = Node(data)
                else:
                    self.right.insert(data)
        else:
            self.data = data

    
# Print the tree
    def PrintTree(self):
        if self.left:
            self.left.PrintTree()
        print( self.data),
        if self.right:
            self.right.PrintTree()
        
            
     #find the value in the tree       
    def findval(self, lkpval): #root is self, 
        if lkpval < self.data: #if key is <root.node, parse left
            if self.left is None: #if reached to the end , Means, "not found"
                return str(lkpval)+" is not Found"
            return self.left.findval(lkpval) # if else return iterate remaining node
        elif lkpval > self.data: #if key > root, parse the right
            if self.right is None: #if it reached till the end, return "not found"
                return str(lkpval)+" is not Found"
            return self.right.findval(lkpval)  #iterate iterate rigth tree
        else:
            return str(self.data) + " is found"  #val found 

# Given two trees, return true if they are structurally identical
#Hint Depth first traversal
#Another approach can be thinking that if two trees are identical, their preorder, inorder and postorder traversals will also be same.
def identicalTrees(a, b):
     
    # 1. Both empty
    if a is None and b is None:
        return True
 
    # 2. Both non-empty -> Compare them
    if a is not None and b is not None:
        return ((a.data == b.data) and
                identicalTrees(a.left, b.left)and
                identicalTrees(a.right, b.right))
     
    # 3. one empty, one not -- false
    return False


#Binary Search Tree Iterator
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class BSTIterator:
    #Approach
#Push all the left nodes to the stack starting from the root in the constructor. This will push the nodes in descending order.
#In the hasNext() return true if the stack has elements and false if its empty
#In the next(), pop the node from the stack, push to the stack the right subtree of this node and return its value.

    __stack = []
    def __init__(self, root: Optional[TreeNode]):
        	# Initializing stack
        curr = root
        while (curr is not None):
            self.__stack.append(curr)
            if curr:
                print("adding at", curr.val)
            curr = curr.left
        print("stacklen", len(self.__stack))
    
    def pushtoleft(self,root):
        curr = root
        if curr:
            self.__stack.append(curr)
            print("adding",curr.val)
            self.pushtoleft(curr.left)
    def next(self) -> int:
        print("stackl", self.__stack)
        curr = self.__stack[-1].right
        
        if curr:
            print("right", curr.val)
        else:
            print(curr)
        tmp = self.__stack.pop()
        print(tmp.val)
       # while (curr is not None):
       #     self.__stack.append(curr)
        #    curr = curr.left
        self.pushtoleft(curr)
        print("stack after", self.__stack)
        
        return tmp.val

    def hasNext(self) -> bool:
        return  len(self.__stack)
        


# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()







# This code is added by Amartya Ghosh

# Use the insert method to add nodes
root = Node(27)
root.insert(14)
root.insert(35)
root.insert(31)
root.insert(10)
root.insert(19)
root.insert(19)
#print(root.findval(7))
root.PrintTree()
